import os
import json
from colorama import init, Fore, Style
init()
import time
import re
import shutil
import subprocess
import traceback
from datetime import datetime, timezone

from config import base_path, request_file, response_file, history_file

def log_action(message):
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
    with open(history_file, "a", encoding="utf-8") as f:
        f.write(f"[{timestamp}] {message}\n")

        with open(history_file, "a", encoding="utf-8") as f:
            f.write(f"[DIFF ERROR] {filepath}: {str(e)}\n")

def save_to_memory(cmd):
    memory_file = os.path.join(base_path, ".ben_memory.json")
    try:
        if os.path.exists(memory_file):
            with open(memory_file, "r", encoding="utf-8") as f:
                memory = json.load(f)
        else:
            memory = []
        cmd["timestamp"] = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
        memory.append(cmd)
        with open(memory_file, "w", encoding="utf-8") as f:
            json.dump(memory[-100:], f, indent=2, ensure_ascii=False)
    except Exception as e:
        log_action(f"‚ö†Ô∏è Error saving to memory: {str(e)}")

def read_requests():
    if not os.path.exists(request_file):
        return []
    with open(request_file, "r", encoding="utf-8") as f:
        try:
            text = f.read().strip()
            if not text:
                return []
            data = json.loads(text)
            return data if isinstance(data, list) else [data]
        except Exception as e:
            return [{"status": "error", "message": f"‚ùå JSON error: {str(e)}"}]

def write_response(responses):
    with open(response_file, "w", encoding="utf-8") as f:
        json.dump(responses, f, indent=2, ensure_ascii=False)

def clear_cache():
    with open(request_file, "w", encoding="utf-8") as f:
        f.write("")

def handle_command(cmd):
    required_keys = ["action"]
    for key in required_keys:
        if key not in cmd:
            return {"status": "error", "message": f"‚ùå Missing required field: {key}"}
    try:
        action = cmd.get("action")
        filename = cmd.get("filename")
        foldername = cmd.get("foldername")
        content = cmd.get("content", "")
        pattern = cmd.get("pattern")
        replacement = cmd.get("replacement")
        target_folder = cmd.get("target_folder")
        new_name = cmd.get("new_name")

        full_file_path = os.path.join(base_path, filename) if filename else None
        full_folder_path = os.path.join(base_path, foldername) if foldername else None
        dst_folder_path = os.path.join(base_path, target_folder) if target_folder else None
        dst_file_path = os.path.join(dst_folder_path, filename) if target_folder and filename else None

        if action == "create_file":
            with open(full_file_path, "w", encoding="utf-8") as f:
                f.write(content)
            save_to_memory(cmd)  
            return {"status": "success", "message": f"‚úÖ Created file '{filename}'"}

        elif action == "append_file":
            with open(full_file_path, "a", encoding="utf-8") as f:
                f.write(content)
            save_to_memory(cmd)
            return {"status": "success", "message": f"üìå Appended to file '{filename}'"}
        elif action == "scan_all_files":
            result = {}
            for fname in os.listdir(base_path):
                fpath = os.path.join(base_path, fname)
                if os.path.isfile(fpath) and fname.endswith((".py", ".json", ".txt", ".csv")):
                    try:
                        with open(fpath, "r", encoding="utf-8") as f:
                            result[fname] = f.read()
                    except Exception as e:
                        result[fname] = f"‚ö†Ô∏è Error reading: {str(e)}"
            return {"status": "success", "files": result}

        elif action == "update_file":
            if os.path.exists(full_file_path):
                with open(full_file_path, "r", encoding="utf-8") as f:
                    data = f.read()
                updated = re.sub(pattern, replacement, data)
                with open(full_file_path, "w", encoding="utf-8") as f:
                    f.write(updated)
                save_to_memory(cmd)
                return {"status": "success", "message": f"üîÅ Updated file '{filename}'"}
            else:
                return {"status": "error", "message": "File not found"}

        elif action == "replace_in_file":
            if filename.endswith('.py'):
                test_result = handle_command({"action": "test_python", "filename": filename})
            if test_result.get("status") == "error":
                return {"status": "error", "message": f"‚ùå –ü–µ—Ä–µ–¥ –∑–º—ñ–Ω–æ—é: {test_result.get('message')}"}
            if filename in ["config.py", "api_keys.py", "cache.txt"]:
                return {"status": "error", "message": f"‚ùå –ó–∞–±–æ—Ä–æ–Ω–µ–Ω–æ –∑–º—ñ–Ω—é–≤–∞—Ç–∏ –∫—Ä–∏—Ç–∏—á–Ω–∏–π —Ñ–∞–π–ª: {filename}"}
            if os.path.exists(full_file_path):
                with open(full_file_path, "r", encoding="utf-8") as f:
                    text = f.read()
                # üß† –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Ä–µ–∑–µ—Ä–≤–Ω—É –∫–æ–ø—ñ—é
                backup_path = full_file_path + ".bak"
                with open(backup_path, "w", encoding="utf-8") as f:
                    f.write(text)
                # üìù Git diff –ø–µ—Ä–µ–¥ –∑–∞–ø–∏—Å–æ–º
                try:
                    diff_output = subprocess.check_output(["git", "diff", full_file_path], cwd=base_path, text=True)
                    if diff_output.strip():
                        log_action("üìÑ Git diff –ø–µ—Ä–µ–¥ –∑–º—ñ–Ω–æ—é:" + diff_output)
                except Exception as e:
                    log_action(f"‚ö†Ô∏è Git diff error: {str(e)}")
                # üîÅ –ó–∞–º—ñ–Ω–∞ —á–µ—Ä–µ–∑ regex
                new_text = re.sub(pattern, replacement, text)
                with open(full_file_path, "w", encoding="utf-8") as f:
                    f.write(new_text)
                    
                # üìú –õ–æ–≥ –∑–º—ñ–Ω (git diff)
                log_diff(full_file_path)
                save_to_memory(cmd)
                return {"status": "success", "message": f"‚úèÔ∏è Replaced text in '{filename}'"}
        elif action == "read_file":
            if os.path.exists(full_file_path):
                with open(full_file_path, "r", encoding="utf-8") as f:
                    return {"status": "success", "content": f.read()}
            save_to_memory(cmd)
            return {"status": "error", "message": "File not found"}

        elif action == "search_text_in_file":
            if os.path.exists(full_file_path):
                with open(full_file_path, "r", encoding="utf-8") as f:
                    lines = f.readlines()
                matches = [line for line in lines if pattern in line]
                return {"status": "success", "matches": matches}

        elif action == "create_folder":
            os.makedirs(full_folder_path, exist_ok=True)
            return {"status": "success", "message": f"üìÅ Folder '{foldername}' created"}

        elif action == "delete_file":
            if os.path.exists(full_file_path):
                os.remove(full_file_path)
                save_to_memory(cmd)
                return {"status": "success", "message": f"üóëÔ∏è File '{filename}' deleted"}
            else:
                return {"status": "error", "message": f"File '{filename}' not found"}

        elif action == "rename_file":
            if not os.path.exists(full_file_path):
                return {"status": "error", "message": f"‚ùå File '{filename}' not found"}
            new_path = os.path.join(base_path, new_name)
            os.rename(full_file_path, new_path)
            save_to_memory(cmd)
            return {"status": "success", "message": f"üìÑ File renamed to '{new_name}'"}

        elif action == "copy_file":
            shutil.copy(full_file_path, dst_file_path)
            save_to_memory(cmd)
            return {"status": "success", "message": f"üìÇ Copied '{filename}' to '{target_folder}'"}

        elif action == "read_folder":
            if os.path.exists(full_folder_path):
                files = os.listdir(full_folder_path)
                return {"status": "success", "files": files}
            return {"status": "error", "message": "Folder not found"}

        elif action == "run_python":
            if not os.path.exists(full_file_path):
                return {"status": "error", "message": f"‚ùå File '{filename}' not found"}
            result = subprocess.run(["python", full_file_path], capture_output=True, text=True)
            return {"status": "success", "output": result.stdout, "errors": result.stderr}
        
        elif action == "test_python":
            if os.path.exists(full_file_path):
                try:
                    with open(full_file_path, "r", encoding="utf-8") as f:
                        source = f.read()
                    compile(source, filename, 'exec')
                    return {"status": "success", "message": f"‚úÖ {filename} –ø—Ä–æ–π—à–æ–≤ —Å–∏–Ω—Ç–∞–∫—Å–∏—á–Ω—É –ø–µ—Ä–µ–≤—ñ—Ä–∫—É"}
                except SyntaxError as e:
                    return {"status": "error", "message": f"‚ùå Syntax error in {filename}: {e}"}
            return {"status": "error", "message": "File not found"}

        elif action == "undo_change":
            if os.path.exists(full_file_path + ".bak"):
                shutil.copy(full_file_path + ".bak", full_file_path)
                save_to_memory(cmd)
                return {"status": "success", "message": f"‚Ü©Ô∏è Undo: –≤—ñ–¥–∫–∞—Ç –¥–æ .bak –¥–ª—è '{filename}'"}
            else:
                return {"status": "error", "message": f"‚ùå –ù–µ–º–∞—î —Ä–µ–∑–µ—Ä–≤–Ω–æ—ó –∫–æ–ø—ñ—ó –¥–ª—è '{filename}'"}

        elif action == "macro":
            if not isinstance(cmd.get("steps"), list):
                return {"status": "error", "message": "‚ùå Invalid macro steps"}
            results = []
            for step in cmd.get("steps", []):
                result = handle_command(step)
                results.append(result)
            return {"status": "success", "steps": results}

        elif action == "list_files":
            return {"status": "success", "files": os.listdir(base_path)}

        elif action == "check_status":
            return {"status": "success", "message": "üü¢ Agent is running"}

        elif action == "show_memory":
            memory_file = os.path.join(base_path, ".ben_memory.json")
            if os.path.exists(memory_file):
                with open(memory_file, "r", encoding="utf-8") as f:
                    memory = json.load(f)
                return {"status": "success", "memory": memory[-20:]}
            else:
                return {"status": "error", "message": "‚ùå Memory file not found"}

        else:
            return {"status": "error", "message": f"‚ùå Unknown action: {action}"}


    except Exception as e:
        traceback.print_exc()
        return {"status": "error", "message": f"‚ùå Exception: {str(e)}"}

if __name__ == "__main__":
    print("üü¢ –ë–µ–Ω –∑–∞–ø—É—â–µ–Ω–∏–π —ñ —Å–ª—É—Ö–∞—î –∫–æ–º–∞–Ω–¥–∏ –∑ cache.txt...")
    while True:
        commands = read_requests()
        print("üì© –û—Ç—Ä–∏–º–∞–Ω–æ –∫–æ–º–∞–Ω–¥–∏:", commands)  # –ü–æ–∫–∞–∑—É—î, —á–∏ —â–æ—Å—å —î –≤ cache.txt

        responses = []
        for cmd in commands:
            result = handle_command(cmd)
            print("‚úÖ –í–∏–∫–æ–Ω–∞–Ω–æ:", result)  # –ü–æ–∫–∞–∑—É—î —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∫–æ–∂–Ω–æ—ó –¥—ñ—ó
            responses.append(result)
            log_action(result.get("message", str(result)))
            if result.get("status") == "success":
                push_result = git_auto_push(f"‚úÖ Auto-commit: {cmd.get('action')} {cmd.get('filename', '')}")
                print(push_result.get('message', ''))
                git_auto_push(f"‚úÖ Auto-commit: {cmd.get('action')} {cmd.get('filename', '')}")

        if responses:
            for r in responses:
                status = r.get('status')
                if status == 'success':
                    print(Fore.GREEN + '‚úÖ', r.get('message', '') + Style.RESET_ALL)
                elif status == 'error':
                    print(Fore.RED + '‚ùå', r.get('message', '') + Style.RESET_ALL)
                elif status == 'cancelled':
                    print(Fore.YELLOW + '‚ö†Ô∏è', r.get('message', '') + Style.RESET_ALL)
                elif status == 'macro':
                    print(Fore.CYAN + 'üì¶ –í–∏–∫–æ–Ω–∞–Ω–æ macro-–∫–æ–º–∞–Ω–¥—É:' + Style.RESET_ALL)
                    for step_result in r.get('results', []):
                        print('  -', step_result.get('message', ''))

            print("üíæ –ó–∞–ø–∏—Å—É—é gpt_response.json —ñ –æ—á–∏—â–∞—é cache.txt")
            write_response(responses)
            clear_cache()
        time.sleep(1)



def git_auto_push(commit_msg="üöÄ Auto-commit by Ben"):
    try:
        subprocess.run(["git", "add", "."], cwd=base_path, check=True)

        # üîç –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —á–∏ —î –∑–º—ñ–Ω–∏
        diff_result = subprocess.run(["git", "diff", "--cached", "--quiet"], cwd=base_path)
        if diff_result.returncode == 0:
            log_action("‚ÑπÔ∏è –ù–µ–º–∞—î –∑–º—ñ–Ω –¥–ª—è –∫–æ–º—ñ—Ç—É ‚Äî git push –ø—Ä–æ–ø—É—â–µ–Ω–æ")
            return {"status": "skipped", "message": "‚ÑπÔ∏è No changes to commit"}

        subprocess.run(["git", "commit", "-m", commit_msg], cwd=base_path, check=True)
        subprocess.run(["git", "push"], cwd=base_path, check=True)
        log_action(f"üì§ Git push: {commit_msg}")
        save_to_memory({"action": "git_push", "message": commit_msg})
        return {"status": "success", "message": "üì§ Git push —É—Å–ø—ñ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–æ"}

    except subprocess.CalledProcessError as e:
        log_action(f"‚ùå Git push –ø–æ–º–∏–ª–∫–∞: {str(e)}")
        return {"status": "error", "message": f"‚ùå Git push –ø–æ–º–∏–ª–∫–∞: {str(e)}"}

def repeat_last_action():
    memory_file = os.path.join(base_path, ".ben_memory.json")
    if not os.path.exists(memory_file):
        return {"status": "error", "message": "‚ùå Memory file not found"}
    try:
        with open(memory_file, "r", encoding="utf-8") as f:
            memory = json.load(f)
        if not memory:
            return {"status": "error", "message": "‚ùå No memory to repeat"}
        last_cmd = memory[-1]
        save_to_memory(last_cmd)
        return handle_command(last_cmd)
    except Exception as e:
        return {"status": "error", "message": f"‚ùå Repeat error: {str(e)}"}


def log_diff(filepath):
    try:
        result = subprocess.run(["git", "diff", filepath], capture_output=True, text=True)
        diff = result.stdout.strip()
        if diff:
            timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
            with open(history_file, "a", encoding="utf-8") as f:
                f.write(f"[DIFF {timestamp}] File: {filepath}\n{diff}\n---\n")
    except Exception as e:
        with open(history_file, "a", encoding="utf-8") as f:
            f.write(f"[DIFF ERROR] {filepath}: {str(e)}\n")


def log_diff(filepath):
    try:
        result = subprocess.run(["git", "diff", filepath], capture_output=True, text=True)
        diff = result.stdout.strip()
        if diff:
            timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
            with open(history_file, "a", encoding="utf-8") as f:
                f.write(f"[DIFF {timestamp}] File: {filepath}\n{diff}\n---\n")
    except Exception as e:
        with open(history_file, "a", encoding="utf-8") as f:
            f.write(f"[DIFF ERROR] {filepath}: {str(e)}\n")
